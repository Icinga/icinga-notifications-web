<?php

namespace Icinga\Module\Notifications\Api\V1;

use Exception;
use GuzzleHttp\Psr7\Response;
use Icinga\Exception\Http\HttpBadRequestException;
use Icinga\Exception\Http\HttpException;
use Icinga\Exception\Json\JsonDecodeException;
use Icinga\Module\Notifications\Api\ApiCore;
use Icinga\Module\Notifications\Api\Elements\HttpMethod;
use Icinga\Module\Notifications\Common\Database;
use Icinga\Util\Json;
use ipl\Sql\Compat\FilterProcessor;
use ipl\Stdlib\Filter\Condition;
use ipl\Web\Filter\QueryString;
use Iterator;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use OpenApi\Attributes as OA;
use Ramsey\Uuid\Uuid;
use Psr\Http\Message\StreamInterface;
use Psr\Http\Server\RequestHandlerInterface;
use ValueError;

/**
 * Base class for API version 1.
 *
 * This class provides common functionality for API endpoints in version 1 of the Icinga Notifications API.
 * It includes methods for handling responses, validating identifiers, and creating filters from query strings.
 *
 * @package Icinga\Module\Notifications\Api\V1
 */
#[OA\OpenApi(
    info: new OA\Info(
        version: '1.0.0',
        description: 'API for managing notification channels',
        title: 'Icinga Notifications API',
    ),
    servers: [
        new OA\Server(
            url: 'http://localhost/icingaweb2/notifications/api/v1',
            description: 'Local server',
        )
    ],
    security: [
        ['BasicAuth' => []],
    ],
)]
#[OA\Tag(
    name: 'Contacts',
    description: 'Operations related to notification Contacts'
)]
#[OA\Tag(
    name: 'Contactgroups',
    description: 'Operations related to notification contactgroups'
)]
#[OA\Tag(
    name: 'Channels',
    description: 'Operations related to notification channels'
)]
#[OA\SecurityScheme(
    securityScheme: 'BasicAuth',
    type: 'http',
    description: 'Basic authentication for API access',
    scheme: 'basic',
)]
abstract class ApiV1 extends ApiCore implements RequestHandlerInterface
{
    /**
     * Suffix for plural method names.
     *
     * This constant is used to differentiate between singular and plural method names
     *
     * @var string
     */
    protected const PLURAL_SUFFIX = 'Plural';
    /**
     * API version.
     *
     * This constant defines the version of the API.
     *
     * @var string
     */
    public const VERSION = 'v1';

    protected function init(): void
    {
        $this->setDB(Database::get());
    }


    /**
     * Handle the incoming server request and return a response.
     *
     * This method processes the incoming request, determines the appropriate method to call
     * based on the HTTP method and presence of an identifier, and invokes that method.
     * It also handles validation of the identifier and request body for POST and PUT requests.
     *
     * @param ServerRequestInterface $request The incoming server request.
     * @return ResponseInterface The response generated by the invoked method.
     * @throws HttpBadRequestException If the request is not valid.
     * @throws HttpException If the requested method does not exist.
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        $httpMethod = $request->getMethod();
        $identifier = $request->getAttribute('identifier');
        $filterStr = $request->getUri()->getQuery();


        if (
            $httpMethod === HttpMethod::get->value
            && empty($identifier)
            && method_exists($this, HttpMethod::get->name . self::PLURAL_SUFFIX)
        ) {
            $methodName = HttpMethod::get->name . self::PLURAL_SUFFIX;
        } else {
            try {
                $methodName = HttpMethod::from($httpMethod)->name;
            } catch (ValueError $e) {
                throw (new HttpException(405, "HTTP method $httpMethod is not supported"))
                    ->setHeader('Allow', $this->getAllowedMethods());
            }

            if (! method_exists($this, $methodName)) {
                throw (new HttpException(
                    405,
                    "Method $httpMethod is not supported for endpoint "
                    . (new \ReflectionClass($this))->getShortName()
                ))->setHeader('Allow', $this->getAllowedMethods());
            }
        }

        if (HttpMethod::tryFrom($httpMethod) === null) {
            throw new HttpException(405, "HTTP method $httpMethod is not supported.");
        }

        if ($httpMethod !== HttpMethod::get->value && ! empty($filterStr)) {
            throw new HttpBadRequestException(
                'Unexpected query parameter: Filter is only allowed for GET requests'
            );
        } elseif ($httpMethod === HttpMethod::get->value && ! empty($identifier) && ! empty($filterStr)) {
            throw new HttpBadRequestException(
                "Invalid request: $httpMethod with identifier and query parameters,"
                . " it's not allowed to use both together."
            );
        } elseif (in_array($httpMethod, [HttpMethod::put->value, HttpMethod::delete->value]) && empty($identifier)) {
            throw new HttpBadRequestException("Invalid request: Identifier is required");
        } elseif (
            in_array($httpMethod, [HttpMethod::put->value, HttpMethod::post->value])
            && $request->getHeaderLine('Content-Type') !== 'application/json'
        ) {
            throw new HttpBadRequestException('Invalid request header: Content-Type must be application/json');
        } elseif (
            ! in_array($httpMethod, [HttpMethod::put->value, HttpMethod::post->value])
            && (! empty($request->getBody()->getSize()) || ! empty($request->getParsedBody()))
        ) {
            throw new HttpBadRequestException('Invalid request: Body is only allowed for POST and PUT requests');
        }

        if (! empty($identifier) && ! Uuid::isValid($identifier)) {
            throw new HttpBadRequestException('The given identifier is not a valid UUID');
        }

        $responseData = match ($httpMethod) {
            self::PUT, self::POST => $this->$methodName($identifier, $this->getValidRequestBody($request)),
            self::GET => str_contains($methodName, self::PLURAL_SUFFIX)
                ? $this->$methodName($filterStr)
                : $this->$methodName($identifier),
            self::DELETE => $this->$methodName($identifier),
            default => throw new HttpBadRequestException("Invalid request: This case shouldn't be reachable."),
        };

        return new Response(...$responseData);
    }


    //TODO: decide if these following functions should be versioned or moved to ApiCore

    /**
     * Create a filter from the filter string.
     *
     * This method parses the filter string and returns an array of filter rules.
     * If the filter string is empty, it returns false.
     *
     * @param callable $listener A listener function to handle conditions in the query string.
     * @return array|bool Returns an array of filter rules or false if no filter string is provided.
     * @throws HttpBadRequestException If the filter string cannot be parsed.
     */
    protected function createFilterFromFilterStr(string $filterStr, callable $listener): array|bool
    {
        if (! empty($filterStr)) {
            try {
                $filterRule = QueryString::fromString($filterStr)
                    ->on(
                        QueryString::ON_CONDITION,
                        $listener
                    )->parse();

                return FilterProcessor::assembleFilter($filterRule);
            } catch (Exception $e) {
                throw new HttpBadRequestException($e->getMessage());
            }
        }
        return false;
    }

    /**
     * Create a filter rule listener for validating allowed columns.
     *
     * This method returns a callable that can be used as a listener for filter conditions.
     * The listener checks if the column in the condition is among the allowed columns.
     * If the column is 'id', it also validates that the value is a valid UUID and
     * changes the column to 'external_uuid'.
     *
     * @param array $allowedColumns An array of allowed column names.
     * @return callable A listener function for filter conditions.
     */
    protected function createFilterRuleListener(array $allowedColumns, string $idColumnName): callable
    {
        return function (Condition $condition) use ($allowedColumns, $idColumnName) {
            $column = $condition->getColumn();
            if (! in_array($column, $allowedColumns)) {
                throw new HttpBadRequestException(
                    sprintf(
                        'Invalid request parameter: Filter column %s given, only %s are allowed',
                        $column,
                        preg_replace('/,([^,]*)$/', ' and$1', implode(', ', $allowedColumns))
                    )
                );
            }

            if ($column === 'id') {
                if (! Uuid::isValid($condition->getValue())) {
                    throw new HttpBadRequestException('The given filter id is not a valid UUID');
                }

                $condition->setColumn($idColumnName);
            }
        };
    }

    /**
     * Validate that the request has a JSON content type and return the parsed JSON content.
     *
     * @param ServerRequestInterface $request The request object to validate.
     * @return array The validated JSON content as an associative array.
     * @throws HttpBadRequestException If the content type is not application/json.
     */
    private function getValidRequestBody(ServerRequestInterface $request): array
    {
        if (! empty($parsedBody = $request->getParsedBody()) && is_array($parsedBody)) {
            return $parsedBody;
        }

        $msgPrefix = 'Invalid request body: ';
        $body = $request->getBody()->getContents();
        if (empty($body)) {
            throw new HttpBadRequestException($msgPrefix . 'given content is empty');
        }

        try {
            $validBody = Json::decode($body, true);
        } catch (JsonDecodeException $e) {
            throw new HttpBadRequestException($msgPrefix . 'given content is not a valid JSON');
        }

        return $validBody;
    }

    protected function getAllowedMethods(): string
    {
        $methods = [];
        foreach (HttpMethod::cases() as $method) {
            if (method_exists($this, $method->name)) {
                $methods[] = $method->value;
            }
        }

        return implode(', ', $methods);
    }
}
