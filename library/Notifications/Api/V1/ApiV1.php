<?php

namespace Icinga\Module\Notifications\Api\V1;

use Exception;
use GuzzleHttp\Psr7\Utils;
use Icinga\Exception\Http\HttpBadRequestException;
use Icinga\Exception\Http\HttpException;
use Icinga\Module\Notifications\Api\ApiCore;
use Icinga\Module\Notifications\Common\Database;
use InvalidArgumentException;
use ipl\Sql\Compat\FilterProcessor;
use ipl\Stdlib\Filter\Condition;
use ipl\Web\Filter\QueryString;
use ipl\Web\Url;
use Iterator;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use OpenApi\Attributes as OA;
use Icinga\Module\Notifications\Api\Elements\Uuid;
use Psr\Http\Message\StreamInterface;

/**
 * Base class for API version 1.
 *
 * This class provides common functionality for API endpoints in version 1 of the Icinga Notifications API.
 * It includes methods for handling responses, validating identifiers, and creating filters from query strings.
 *
 * @package Icinga\Module\Notifications\Api\V1
 */
#[OA\OpenApi(
    info: new OA\Info(
        version: "1.0.0",
        description: "API for managing notification channels",
        title: "Icinga Notifications API",
    ),
    servers: [
        new OA\Server(
            url: "http://localhost/icingaweb2/notifications/api/v1",
            description: "Local server",
        )
    ],
    security: [
        new OA\SecurityScheme(
            ref: '#/components/securitySchemes/BasicAuth',
        ),
    ],
)]
#[OA\Tag(
    name: "Contacts",
    description: "Operations related to notification Contacts"
)]
#[OA\Tag(
    name: "Contactgroups",
    description: "Operations related to notification contactgroups"
)]
#[OA\Tag(
    name: "Channels",
    description: "Operations related to notification channels"
)]
#[OA\SecurityScheme(
    securityScheme: 'BasicAuth',
    type: 'http',
    description: 'Basic authentication for API access',
    name: 'BasicAuth',
    scheme: 'basic',
)]
abstract class ApiV1 extends ApiCore
{
    /**
     * Suffix for plural method names.
     *
     * This constant is used to differentiate between singular and plural method names
     *
     * @var string
     */
    protected const PLURAL_SUFFIX = 'Plural';

    public function __construct(readonly string $version = 'v1')
    {
        parent::__construct();
    }

    protected function init(): void
    {
        $this->setDB(Database::get());
        $this->setResponse(
            $this->getResponse()
                ->withStatus(200)
                ->withHeader('Content-Type', 'application/json')
        );
    }


    /**
     * Handle the incoming server request and return a response.
     *
     * This method processes the incoming request, determines the appropriate method to call
     * based on the HTTP method and presence of an identifier, and invokes that method.
     * It also handles validation of the identifier and request body for POST and PUT requests.
     *
     * @param ServerRequestInterface $request The incoming server request.
     * @return ResponseInterface The response generated by the invoked method.
     * @throws HttpBadRequestException If the request is not valid.
     * @throws HttpException If the requested method does not exist.
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        $httpMethod = $request->getMethod();
        $filterStr = $request->getUri()->getQuery();
        $identifier = $request->getAttribute('identifier');
        $methodMap = [
            self::GET => (empty($identifier) && method_exists($this, strtolower(self::GET) . self::PLURAL_SUFFIX))
                ? strtolower(self::GET) . self::PLURAL_SUFFIX : strtolower(self::GET),
            self::POST => strtolower(self::POST),
            self::PUT => strtolower(self::PUT),
            self::DELETE => strtolower(self::DELETE),
        ];

        if (! in_array($httpMethod, array_keys($methodMap))) {
            $this->httpMethodNotAllowed("HTTP method $httpMethod is not supported.");
        }
        $methodName = $methodMap[$httpMethod];

        if (! method_exists($this, $methodName)) {
            $this->httpMethodNotAllowed(
                "Method $httpMethod is not available in "
                . (new \ReflectionClass($this))->getShortName() . "."
            );
        }

        // Validate that Method with parameters or identifier is allowed
        if ($httpMethod !== self::GET && ! empty($filterStr)) {
            $this->httpBadRequest(
                "Invalid request: Filter is only allowed for GET requests"
            );
        } elseif ($httpMethod === self::GET && ! empty($identifier) && ! empty($filterStr)) {
            $this->httpBadRequest(
                "Invalid request: $httpMethod with identifier and query parameters,"
                . " it's not allowed to use both together."
            );
        }
        $uuid = $this->getValidatedIdentifier($identifier);

        switch ($httpMethod) {
            case self::POST:
            case self::PUT:
                $responseData = $this->$methodName($uuid, $this->getValidRequestBody($request));
                break;
            case self::GET:
                $arg = str_contains($methodName, self::PLURAL_SUFFIX) ? $filterStr : $uuid;
                $responseData = $this->$methodName($arg);
                break;
            case self::DELETE:
                $responseData = $this->$methodName($uuid);
                break;
            default:
                $this->httpBadRequest("Invalid request: This case shouldn't be reachable.");
        }

        return $this->createResponse($responseData);
    }

    //TODO: decide if these following functions should be versioned or moved to ApiCore
    /**
     * Validate the identifier to ensure it is a valid UUID.
     * If the identifier is not valid, it will throw a Bad Request HTTP exception.
     * If a valid identifier is provided, it will be stored in the `identifier` property.
     *
     * @param ?string $identifier
     * @return ?Uuid
     * @throws HttpBadRequestException
     */
    protected function getValidatedIdentifier(?string $identifier): ?Uuid
    {
        if (! empty($identifier)) {
            try {
                $uuid = new Uuid($identifier);
            } catch (InvalidArgumentException $e) {
                $this->httpBadRequest('The given identifier is not a valid UUID');
            }

            return $uuid;
        }

        return null;
    }

    /**
     * Create a filter from the filter string.
     *
     * This method parses the filter string and returns an array of filter rules.
     * If the filter string is empty, it returns false.
     *
     * @param callable $listener A listener function to handle conditions in the query string.
     * @return array|bool Returns an array of filter rules or false if no filter string is provided.
     * @throws HttpBadRequestException If the filter string cannot be parsed.
     */
    protected function createFilterFromFilterStr(callable $listener): array|bool
    {
        if (! empty($filterStr = Url::fromRequest()->getQueryString())) {
            try {
                $filterRule = QueryString::fromString($filterStr)
                    ->on(
                        QueryString::ON_CONDITION,
                        $listener
                    )->parse();

                return FilterProcessor::assembleFilter($filterRule);
            } catch (Exception $e) {
                $this->httpBadRequest($e->getMessage());
            }
        }
        return false;
    }

    /**
     * Create a filter rule listener for validating allowed columns.
     *
     * This method returns a callable that can be used as a listener for filter conditions.
     * The listener checks if the column in the condition is among the allowed columns.
     * If the column is 'id', it also validates that the value is a valid UUID and
     * changes the column to 'external_uuid'.
     *
     * @param array $allowedColumns An array of allowed column names.
     * @return callable A listener function for filter conditions.
     */
    protected function createFilterRuleListener(array $allowedColumns, string $idColumnName): callable
    {
        return function (Condition $condition) use ($allowedColumns, $idColumnName) {
            $column = $condition->getColumn();
            if (! in_array($column, $allowedColumns)) {
                $this->httpBadRequest(
                    sprintf(
                        'Invalid filter column %s given, only %s are allowed',
                        $column,
                        preg_replace('/,([^,]*)$/', ' and$1', implode(', ', $allowedColumns))
                    )
                );
            }

            if ($column === 'id') {
                if (! Uuid::isValid($condition->getValue())) {
                    $this->httpBadRequest('The given filter id is not a valid UUID');
                }

                $condition->setColumn($idColumnName);
            }
        };
    }

    /**
     * Create an array of response data.
     *
     * This method constructs an array containing the status code, body, and headers to create a response.
     *
     * @param ?int $statusCode The HTTP status code for the response.
     * @param ?array $additionalHeaders An associative array of additional headers to include in the response.
     * @param bool|callable|float|int|Iterator|null|StreamInterface|string $body The body of the response.
     * @return array An associative array containing 'status', 'body', and 'headers' keys.
     */
    protected function createArrayOfResponseData(
        int $statusCode = null,
        bool|callable|float|int|Iterator|null|StreamInterface|string $body = null,
        array $additionalHeaders = null,
    ): array {

        return array_filter([
            'status' => $statusCode,
            'body' => $body,
            'headers' => $additionalHeaders,
        ], static fn($v) => $v !== null);
    }

    /**
     * Create a ResponseInterface object from the given response data.
     *
     * This method constructs a ResponseInterface object using the provided response data array.
     * It sets the status code, headers, and body of the response based on the data in the array.
     *
     * @param array $responseData An associative array containing 'status', 'body', and 'headers' keys.
     * @return ResponseInterface The constructed ResponseInterface object.
     */
    protected function createResponse(array $responseData): ResponseInterface
    {
        $response = $this->getResponse();

        if (isset($responseData['status'])) {
            $response = $response->withStatus($responseData['status']);
        }
        if (isset($responseData['headers']) && is_array($responseData['headers'])) {
            foreach ($responseData['headers'] as $name => $values) {
                if (is_array($values)) {
                    foreach ($values as $value) {
                        $response = $response->withHeader($name, $value);
                    }
                } else {
                    $response = $response->withHeader($name, $values);
                }
            }
        }
        if (isset($responseData['body'])) {
            $response = $response->withBody(Utils::streamFor($responseData['body']));
        }

        return $response;
    }
}
