<?php

namespace Icinga\Module\Notifications\Api;

use GuzzleHttp\Psr7\Response;
use Icinga\Exception\Http\HttpBadRequestException;
use Icinga\Exception\Http\HttpException;
use Icinga\Module\Notifications\Api\Elements\HttpMethod;
use LogicException;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Ramsey\Uuid\Uuid;
use ValueError;

abstract class ApiCore implements RequestHandlerInterface
{
    /**
     * Suffix for plural method names.
     *
     * This constant is used to differentiate between singular and plural method names
     *
     * @var string
     */
    protected const PLURAL_SUFFIX = 'Plural';

    /**
     * Handle the API request and return a Response object.
     *
     * This method should be implemented by subclasses to handle the specific API request
     * by calling the appropriate methods of the endpoint based on the HTTP method
     * and return a Response object.
     *
     * @return Response
     */
    abstract protected function handleRequest(ServerRequestInterface $request): ResponseInterface;

    /**
     * Get the endpoint path for the API.
     *
     * This method returns the endpoint path for the API, which is defined by the ENDPOINT constant.
     * If the ENDPOINT constant is not defined in the subclass, a LogicException is thrown.
     *
     * @return string
     * @throws LogicException
     */
    abstract public function getEndpoint(): string;

    /**
     * Handle the incoming server request and return a response.
     *
     * This method processes the incoming request, determines the appropriate method to call
     * based on the HTTP method and presence of an identifier, and invokes that method.
     * It also handles validation of the identifier and request body for POST and PUT requests.
     *
     * @param ServerRequestInterface $request The incoming server request.
     * @return ResponseInterface The response generated by the invoked method.
     * @throws HttpBadRequestException If the request is not valid.
     * @throws HttpException If the requested method does not exist.
     */
    public function handle(ServerRequestInterface $request): ResponseInterface
    {
        try {
            $httpMethod = HttpMethod::from(strtolower($request->getMethod()));
        } catch (ValueError) {
            throw (new HttpException(405, 'HTTP method ' . $request->getMethod() . ' is not supported'))
                ->setHeader('Allow', $this->getAllowedMethods());
        }
        $request = $request->withAttribute('httpMethod', $httpMethod);
        $identifier = $request->getAttribute('identifier');
        $filterStr = $request->getUri()->getQuery();


        if (! method_exists($this, $httpMethod->lowercase())) {
            throw (new HttpException(
                405,
                'Method ' . $httpMethod->uppercase() . ' is not supported for endpoint ' . $this->getEndpoint()
            ))
                ->setHeader('Allow', $this->getAllowedMethods());
        }

        if ($httpMethod !== HttpMethod::GET && ! empty($filterStr)) {
            throw new HttpBadRequestException(
                'Unexpected query parameter: Filter is only allowed for GET requests'
            );
        }
        if ($httpMethod === HttpMethod::GET && ! empty($identifier) && ! empty($filterStr)) {
            throw new HttpBadRequestException(
                'Invalid request: ' . $httpMethod->uppercase() . ' with identifier and query parameters,'
                . " it's not allowed to use both together."
            );
        }
        if (
            in_array($httpMethod, [HttpMethod::PUT, HttpMethod::POST])
            && $request->getHeaderLine('Content-Type') !== 'application/json'
        ) {
            throw new HttpBadRequestException('Invalid request header: Content-Type must be application/json');
        }
        if (
            ! in_array($httpMethod, [HttpMethod::PUT, HttpMethod::POST])
            && (! empty($request->getBody()->getSize()) || ! empty($request->getParsedBody()))
        ) {
            throw new HttpBadRequestException('Invalid request: Body is only allowed for POST and PUT requests');
        }
        if (in_array($httpMethod, [HttpMethod::PUT, HttpMethod::DELETE]) && empty($identifier)) {
            throw new HttpBadRequestException("Invalid request: Identifier is required");
        }

        $this->assertValidRequest($request);

        return $this->handleRequest($request);
    }

    /**
     * Validate the incoming request.
     *
     * This method can be overridden in subclasses to implement API- or module-specific
     * request validation logic. The default implementation checks if the 'identifier'
     * attribute in the request is a valid UUID, if it is present.
     *
     * @param ServerRequestInterface $request The incoming server request to validate.
     * @return void
     * @throws HttpBadRequestException If the identifier is not a valid UUID.
     */
    protected function assertValidRequest(ServerRequestInterface $request): void
    {
        // API- / Module-specific request validation can be implemented in this method in child-classes
    }


    /**
     * Get allowed HTTP methods for the API.
     *
     * @return string
     */
    protected function getAllowedMethods(): string
    {
        $methods = [];
        foreach (HttpMethod::cases() as $method) {
            if (method_exists($this, $method->lowercase())) {
                $methods[] = $method->uppercase();
            }
        }

        return implode(', ', $methods);
    }

    /**
     * Create a Response object from the given data array.
     *
     * The data array can contain the following keys:
     * - 'status': The HTTP status code (default: 200)
     * - 'headers': An associative array of HTTP headers (default: empty array)
     * - 'body': The response body as null|StreamInterface|resource|string (default: null)
     *
     * @param int $status
     * @param array $headers
     * @param null $body
     * @param string $version
     * @param string|null $reason
     * @return Response
     */
    protected function createResponse(
        int $status = 200,
        array $headers = [],
        $body = null,
        string $version = '1.1',
        ?string $reason = null
    ): Response {
        return new Response($status, $headers, $body, $version, $reason);
    }
}
